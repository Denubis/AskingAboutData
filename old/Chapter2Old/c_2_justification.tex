\startcomponent c_2_justification
\product prd_Chapter2_Justification
\project project_thesis

An exploration of the philosophy of \IT\ is an overly broad research topic for just one project. \IT\ is a mongrel discipline, employing computational, design, communications, and psychological elements. Within each of those categories is a host of sub-specializations, each with its own unique focus and jargon\footnote{The philosophy of \IT\ education can be seen in this paper on creating a new \IT\ Course\cite{Owen2000}.}. Any attempt to create a comprehensive philosophy of \IT\ is bound to fail. At best, such a philosophy would be a conglomeration of the philosophy of every sub-discipline with some discussion of the links that unify those sub-disciplines into \IT. 

The question has little practical value. Asking about a philosophy of \IT, one that covers and unifies the entire \quotation{field,} is something of mainly academic interest, rather than something that would change the way people understand the discipline, teach it, and use it to carry out real objectives.

\IT\ both suffers and benefits from its multidisciplinarity. One of the key tools taught in \IT-training programs is merely the ability to understand the jargon of the other sub-disciplines of \IT. As a database professional, I can still speak the terminologies of networking, web design, and enterprise systems. The process of communicating in these various jargons, however, necessitates different mental models of the world\footnote{Exploring computer problems and their solutions is an exercise in quickly changing levels of abstraction. Small, vital, and technical details fight tooth and claw against the broad vision of the designer\cite{Medin1989}.}. In addition, each of those individual levels will have its own philosophy. The field is not amenable to a single probe, and even if it were, each sub-discipline understands reality in its own way, as it must to solve problems according to the constructed protocols of that profession.

One thing underlying all of \IT, however, is the use of the term \quotation{data.} Every aspect of \IT\ uses data, but their understanding of what constitutes that data is significantly different. Moreover, in this computerized age, everyone interacts daily with data to some degree. The difficulty is in the question: what is data? 

There is a need for a philosophy of data because conflicting definitions of \quotation{data} inform communications. Peoples' inherent conceptions of data inform how they interact with the constructed data of the world\footnote{From a pragmatic point of view, many linguistic elements are socially constructed and our understanding of them is shaped by our linguistic interactions with other people. Data, being something categorized by humans, is a great example of a linguistic construction\cite{Berger1967}.}. Some people consider data to be objective facts, others consider it to be subjective observations, and still others consider it to be electronically stored signs\footnote{For more details, see the results section, page \at[Summary].}.

When people discuss data, information, and knowledge, their understanding of data informs their understanding of information and knowledge - be it synonymous, Ackoff's hierarchy from 1989, or any of the other hierarchies suggested by the literature\footnote{For more details, see page \at[Ackoff].}. When these different understandings collide, the best case is that the people involved recognize that they have different understandings and create a local trading zone\footnote{Galison proposed the idea of a \quotation{trading zone} where people of different specialties who use different jargon (and potentially different conceptions of the world) establish a way to communicate with each other via the use of a \quotation{local language} (pidgin) that both sides can agree on during communications. For more details, see page \at[Galison].} with words that have functionally identical meanings to both people. In the worst case, both people use the term in the way to which they are accustomed, and errors go uncaught until large mistakes are made.

\stopcomponent
